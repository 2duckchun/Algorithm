## Singly Linked List
- 데이터 : val
- 다음 노드 참조 : next
 
```js
class Node {
  constructor(val) {
    this.val = val
    this.next = null
  }
}

class SinglyLinkedList {
  constructor() {
    this.head = null
    this.tail = null
    this.length = 0
  }

  // push 메서드 - 링크드 리스트의 tail에 노드를 추가함.
  push(val) {
    let newNode = new Node(val)
    if(!this.head) {
      this.head = newNode
      this.tail = this.head
    } else {
      this.tail.next = newNode
      this.tail = newNode
    }
    this.length++
    return this
  }

  // 순회 메서드 - 리스트에 있는 노드들을 head부터 끝까지 순회함.
  traverse() {
    let current = this.head
    while(current) {
      console.log(current)
      current = current.next
    }
  }

  // Pop 메서드 - 링크드 리스트의 마지막 노드를 삭제하고 tail을 반환함.
  /*
  수도코드
  - 리스트에 노드가 없다면, undefined를 리턴
  - tail에 닿을때까지 list를 순회
  - 2번째로 뒤에 있는 노드의 next 프로퍼티를 null로 설정
  - 2번째로 뒤에 있는 노드를 tail로 설정
  - length 1 감소
  - 삭제된 node를 return함
  */
  pop() {
    if (!this.head) return undefined

    let current = this.head
    let newTail = current

    while(current.next) {
      newTail = current
      current = current.next
    }

    this.tail = newTail
    this.tail.next = null
    this.length--

    if(this.length === 0) {
      this.head = null
      this.tail = null
    }
    
    return current
  }

  // shift 메서드 - 리스트의 head노드를 반환 및 제거하고 다음 노드를 head로 만듦
  /* 
  수도코드
  - 리스트에 노드가 없다면, undefined 반환.
  - 현재 head 프로퍼티를 변수에 저장함.
  - 현재의 head 프로퍼티를 head의 next 노드로 만듦.
  - length를 1 줄임.
  - 제거된 노드를 return함
  */
  shift() {
    if (!this.head) return undefined
    const currentHead = this.head
    this.head = this.head.next
    this.length--
    if (this.length === 0) {
      this.tail = null
    }
    return currentHead
  }
}

let list = new SinglyLinkedList()
list.push("Hello")
list.push("Goodbye")
list.push("!")
list.traverse()
```

